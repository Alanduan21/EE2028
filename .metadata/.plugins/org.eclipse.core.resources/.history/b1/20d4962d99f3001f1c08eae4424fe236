/**
 ******************************************************************************
 * @project        : CG/[T]EE2028 Assignment 1 Program Template
 * @file           : main.c
 * @author         : Hou Linxin, ECE, NUS
 * @brief          : Main program body
 ******************************************************************************
 *
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include "stdio.h"
#include <stdint.h>

//****************************************************************************

volatile unsigned int *DWT_CYCCNT   = (volatile unsigned int *)0xE0001004;
volatile unsigned int *DWT_CONTROL  = (volatile unsigned int *)0xE0001000;
volatile unsigned int *DWT_LAR      = (volatile unsigned int *)0xE0001FB0;
volatile unsigned int *SCB_DHCSR    = (volatile unsigned int *)0xE000EDF0;
volatile unsigned int *SCB_DEMCR    = (volatile unsigned int *)0xE000EDFC;
volatile unsigned int *ITM_TER      = (volatile unsigned int *)0xE0000E00;
volatile unsigned int *ITM_TCR      = (volatile unsigned int *)0xE0000E80;

//****************************************************************************

static int Debug_ITMDebug = 0;

//****************************************************************************

void EnableTiming(void)
{
  if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) // Enabled?
    Debug_ITMDebug = 1;

  *SCB_DEMCR |= 0x01000000;
  *DWT_LAR = 0xC5ACCE55; // enable access
  *DWT_CYCCNT = 0; // reset the counter
  *DWT_CONTROL |= 1 ; // enable the counter
}

//****************************************************************************

void Delay(uint32_t cycles)
{
  uint32_t start = *DWT_CYCCNT;

  while((*DWT_CYCCNT - start) < cycles);
}


#define F 3
#define S 2

int entrySize = 5;

extern void asm_func(int* arg1, int* arg2, int* arg3, int* arg4);
extern void initialise_monitor_handles(void);

int main(void)
{
	initialise_monitor_handles();
	EnableTiming();
	int i,j;

	// test case 1
	int building[F][S] = {{8,8},{8,8},{8,8}};
	int entry[5] = {1,2,3,4,5};
	int exit[F][S] = {{1,2},{2,3},{3,4}};

	// test case 2
//	int building[F][S] = {{1,2},{3,4},{5,6}};
//	int entry[5] = {1,1,1,1,1};
//	int exit[F][S] = {{1,0},{0,0},{0,0}};

	// test case 3
//	int building[F][S] = {{12,12},{10,5},{3,7}};
//	int entry[5] = {1,1,1,1,5};
//	int exit[F][S] = {{1,2},{3,4}, {3,6}};

	// test case 4
//	int building[F][S] = {{12,12},{12,12},{12,12}};
//	int entry[5] = {0,0,0,0,0};
//	int exit[F][S] = {{2,2},{3,3},{4,4}};

	// test case 5
//	int building[F][S] = {{9,10},{7,8},{4,4}};
//	int entry[5] = {2,4,6,8,10};
//	int exit[F][S] = {{1,1},{1,1},{1,1}};

	// test case 6 (overflow)
//	int building[F][S] = {{8,8},{8,8},{8,8}};
//	int entry[5] = {2,4,6,8,10};
//	int exit[F][S] = {{0,0},{0,0},{0,0}};

	// test case 7 (0 exit)

//	int building[F][S] = {{8,8},{8,8},{8,8}};
//	int entry[5] = {2,4,6,8,10};
//	int exit[F][S] = {{0,0},{0,0},{0,0}};

	// test case 8 (0 entry)

//	int building[F][S] = {{8,8},{8,8},{8,8}};
//	int entry[5] = {0};
//	int exit[F][S] = {{1,1},{1,1},{1,1}};

	// test case 9 (entry already full)
//	int building[F][S] = {{12, 12}, {5, 6}, {3, 7}};
//	int entry[5] = {1,2,3,4,5};
//	int exit[F][S] = {{1,2}, {3,4}, {3,6}};

//	 test case 10 (variable F*S) remember to change constant above and result array below before testing
//		int building[F][S] = {{8,8},{8,8}};
//		int entry[5] = {0,0,0,0,0};
//		int exit[F][S] = {{1,1},{1,1}};

	// test case 11 (small F*S)
//	int building[F][S] = {5};
//	int entry[5] = {4,5,3,1,1};
//	int exit[F][S] = {{1}};

	// test case 12 (variable entry array length)
//		int building[F][S] = {{8,0},{0,0},{0,0}};
//		int entry[8] = {1,1,1,1,1,1,1,1};
//		int exit[F][S] = {{0,0},{0,0},{0,0}};

	int result[F][S] = {{F,S},{0,0},{0,0},{0,0}};

	uint32_t start_cycles = *DWT_CYCCNT;
	asm_func((int*)building, (int*)entry, (int*)exit, (int*)result);
	uint32_t end_cycles = *DWT_CYCCNT;
	uint32_t cycles_taken = end_cycles - start_cycles;
	printf("Execution time: %u cycles\n", cycles_taken);

	// print result[][]
	printf("RESULT\n");
	for (i=0; i<F; i++)
	{
		for (j=0; j<S; j++)
		{
			building[i][j] = result[i][j];
			printf("%d\t", building[i][j]);
		}
	printf("\n");
	}

}
